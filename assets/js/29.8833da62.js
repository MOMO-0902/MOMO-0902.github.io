(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{65:function(e,t,a){"use strict";a.r(t);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[e._v("#")]),e._v(" 定义")]),a("p",[e._v("axios是一个基于Promise用于浏览器和nodejs的http客户端")]),a("h2",{attrs:{id:"特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特征","aria-hidden":"true"}},[e._v("#")]),e._v(" 特征")]),a("ul",[a("li",[e._v("从浏览器中创建XMLHttpRequest")]),a("li",[e._v("从nodejs发出http请求")]),a("li",[e._v("支持Promise api")]),a("li",[e._v("拦截请求和响应")]),a("li",[e._v("转换请求和响应数据")]),a("li",[e._v("取消请求")]),a("li",[e._v("自动转换json数据")]),a("li",[e._v("客户端支持防止 CSRF/XSRF(跨站请求伪造，也被称为one click attack/session riding，CRSF攻击可理解为攻击者盗用了你的身份，以你的名义发送恶意请求，会导致个人隐私泄露及财产安全问题。)")])]),a("h2",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用")]),a("h3",{attrs:{id:"执行get请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行get请求","aria-hidden":"true"}},[e._v("#")]),e._v(" 执行get请求")]),a("p",[e._v("1.可通过params对象传递参数")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.get(url, {\n  params: {}\n})\n     .then(() => {})\n     .catch(() => {})\n")])]),a("p",[e._v("2.也可直接将参数拼接在路径后边")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.get('/user?id=12321')\n")])]),a("h3",{attrs:{id:"执行post请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行post请求","aria-hidden":"true"}},[e._v("#")]),e._v(" 执行post请求")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.post(url, data)\n")])]),a("h3",{attrs:{id:"执行多个并发请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行多个并发请求","aria-hidden":"true"}},[e._v("#")]),e._v(" 执行多个并发请求")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("getUserAccount() {\n  axios.get('/user/12345')\n}\n\ngetUserPermissions() {\n  axios.get('/user/permissions')\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n     .then(axios.sperad(function(acct,perms) {\n       // 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果\n      }))\n     .catch(() => {})\n")])]),a("h2",{attrs:{id:"配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置")]),a("p",[e._v("可以对axios进行一些设置来生成请求\n1.")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios(config)\naxios({\n  methods,\n  url,\n  data,\n})\n\nex: 发送一个post请求\naxios({\n  methods: 'POST',\n  url: '/user/12321',\n  data: {\n    firstName: 'fred',\n    lastName: 'mary'\n  }\n})\n")])]),a("p",[e._v("2.axios(url[,config])\n发送一个get请求，get是默认请求方式")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios('/user/12321')\n")])]),a("h2",{attrs:{id:"请求方式别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求方式别名","aria-hidden":"true"}},[e._v("#")]),e._v(" 请求方式别名")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.request(config)\naxios.get(url[,config])\naxios.delete(url[,config])\naxios.head(url[,config])\naxios.post(url[,data[,config]])\naxios.put(url,[,data[,config]])\naxios.patch(url,[,data[,config]])\n")])]),a("h2",{attrs:{id:"创建实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建实例","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建实例")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.create([config])\n\nvar instance = axios.create({\n  baseURl: '',\n  timeout: 1000,\n  headers: {}\n})\n")])]),a("h2",{attrs:{id:"实例方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例方法","aria-hidden":"true"}},[e._v("#")]),e._v(" 实例方法")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios#request(config)\naxios#get(url[,config])\naxios#delete(url[,config])\naxios#head(url[,config])\naxios#post(url[,data[,config]])\naxios#put(url,[,data[,config]])\naxios#patch(url,[,data[,config]])\n")])]),a("h2",{attrs:{id:"请求配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 请求配置")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n  url,\n  methods,\n  baseURL,\n  // 对请求数据的改动\n  transformRequest: [function(data) {\n    return data\n  }],\n  // 在数据传送到'then/catch'之前对数据进行改动\n  transformResponse: [function(data) {\n    return data\n  }],\n  headers,\n  params,\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormatL: 'brackets'})\n  },\n  data: {}\n  timeout,\n  // 表示跨域请求时是否需要凭证\n  withCredentials: false,\n  // 允许自定义请求\n  adaptefr: function(config) {},\n  // 'auth'表示应该使用http基础验证，并提供凭据,这将设置一个'Authorization'头，覆写掉现有的任意使用'headers'设置的自定义'Authorization'头\n  auth: {\n    username: '',\n    password: ''\n  },\n  responseType: '',\n  // 承载 xsrf token 的值的http头名称\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  // 允许为上传处理进度事件\n  onUploadProgress: function(progressEvent) {\n    //对原生事件的处理\n  },\n  // 定义允许的响应内容的最大尺寸\n  maxContentLength,\n  根据此函数返回的值定义promise的状态为resolve或rejected\n  validateStatus: function(status) {\n    return status >= 200 && status < 300\n  },\n  // 定义在nodejs中follow是最大重定向数目\n  maxRedirects: 5,\n  // 在nodejs中定义在执行http和https时使用的自定义代理\n  httpAgent: new http.Agent({ keepAlive: true}),\n  httpsAgent: new https.Agent({ keepAlive: true}),\n  // proxy定义代理服务器的主机名称和端口，auth表示http基础验证应当用于连接代理，并提供凭据\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: '',\n      password: ''\n    }\n  },\n  // 指定用于取消请求的cancel token\n  cancelToken: new cancelToken(function(cancel) {})\n}\n")])]),a("h2",{attrs:{id:"响应信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应信息","aria-hidden":"true"}},[e._v("#")]),e._v(" 响应信息")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n  data: {}, //数据\n  status: 200, //状态码\n  statusText: 'OK', // 服务器响应的http状态信息\n  headers: {}, 服务器响应头\n  config: {} //为请求提供的配置信息\n}\n")])]),a("p",[e._v("使用then时可用response参数来接收响应\naxios.get('/user/12321')\n.then(function(response) {\nconsole.log(response.data)\nconsole.log(response.status)\n……\n})")]),a("h2",{attrs:{id:"配置默认值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置默认值","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置默认值")]),a("ul",[a("li",[e._v("全局的axios默认值")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.defaults.baseURL = ''\n// 设置请求头信息为AUTH_TOKEN\naxios.defaluts.headers.common['Authorization'] = AUTH_TOKEN\n// 设置请求的媒体类型\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-fomr-urlencoded'\n// 允许跨域的情况下携带cookie\naxios.defaults.withCredentials = true\n// 标识这是一个ajax请求\naxios.defaults.headers.common['X-Request-With'] = 'XMLHttpRequest'\n")])]),a("h2",{attrs:{id:"自定义实例默认值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义实例默认值","aria-hidden":"true"}},[e._v("#")]),e._v(" 自定义实例默认值")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var instance = axios.create({\n  baseURL: 'https://api.example.com'\n})\n\n// 在实例忆创建后修改默认值\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN\n")])]),a("h2",{attrs:{id:"配置的优先顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置的优先顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置的优先顺序")]),a("p",[e._v("在lib/defaults.js中找到库的默认值，然后是实例的defaults属性，最后是config请求参数")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var instance = axios.create()\n\ninstance.defaults.timeout = 2000\n\ninstance.get('/longRequest', {\n  timeout: 5000\n})\n")])]),a("h2",{attrs:{id:"拦截器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拦截器","aria-hidden":"true"}},[e._v("#")]),e._v(" 拦截器")]),a("p",[e._v("在请求或响应被then或catch之前拦截它们，此例包括封装axios--http.js")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 在请求发出之前拦截\naxios.interceptors.request.use(config => {\n  return config\n}, error => {\n  return Promise.rejected(error)\n})\n\n*ex:\n// 此处在请求发出之前，将config参数中的请求头授权为AUTH_TOKEN\naxios.interceptors.request.use(config => {\n  let AUTH_TOKEN = storage.get('AUTH_TOKEN')\n  if (AUTH_TOKEN) {\n    config.headers['Authorization']\n  }\n})\n\n\n// 在响应之前拦截\naxios.interceptors.response.use(response => {\n  return response\n}, error => {\n  return Promise.rejected(error)\n})\n\n\n* ex:\naxios.interceptors.response.use(response => {\n  if (response.data.retcode === 2000000) {\n    return response.data.data || response.data.data\n  } esle {\n    throw Error(response.data.msg || '服务异常')\n  }\n}, err => {\n  if(err && err.message) {\n    let retcode = err.response.data.retcode\n    // 401为后台返回的状态未登录\n    if (err.response.status === '401') {\n      // 移除token信息\n      storage.remove('AUTH_TOKEN')\n    }\n    if (err.response.status === 500) {\n      err.message = err.response.data.message || '系统异常'\n      err.retcode = retcode\n    }\n  }\n  return Promise.reject(err)\n})\n\nexport default axios\n")])]),a("p",[e._v("封装接口地址api.js")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const prefix = window._CONFIG_.apiPath\nexport default (config => {\n  return Object.keys(config).reduce((copy,name) => {\n    copy[name] = `${prefix}${config[name]}`\n    return copy\n}, {})\n})({\n  // 接口地址\n  user: '/api/user/user'\n  ……\n})\n")])]),a("p",[e._v("定义相关请求server.js")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import api from '../api'\nimpost axios from '../http'\nexport function getUserInfo(userId) {\n  return axios.get(api.user, params)\n}\n")])]),a("p",[e._v("调用相关接口 getUser.js")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import {getUserInfo} from '../server'\ngetUserInfo({userId: userId})\n  .then((resp) => {\n   console.log(resp)\n   if (res.retcode === 2000000) {}\n   if (res.retcode === 300000) {}\n}).catch((err) => {\n    console.log(err.message)\n  })\n")])]),a("h2",{attrs:{id:"移除拦截器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移除拦截器","aria-hidden":"true"}},[e._v("#")]),e._v(" 移除拦截器")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var myInterceptor = axios.interceptors.request.use(config => {})\naxios.interceptor.request.eject(myInterceptor)\n")])]),a("h2",{attrs:{id:"为自定义实例添加拦截器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为自定义实例添加拦截器","aria-hidden":"true"}},[e._v("#")]),e._v(" 为自定义实例添加拦截器")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var instance = axios.create()\ninstance.interceptors.request.use(config => {})\n\n")])]),a("h2",{attrs:{id:"错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误处理","aria-hidden":"true"}},[e._v("#")]),e._v(" 错误处理")]),a("p",[e._v("可以使用validateStatus 配置选项定义一个自定义http状态码的错误范围")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("axios.get('/user/123213', {\n  validateStatus: (status) => {\n    return status< 500 //状态码在大于或等于500时才会reject\n  }\n})\n\n")])]),a("h2",{attrs:{id:"取消请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#取消请求","aria-hidden":"true"}},[e._v("#")]),e._v(" 取消请求")]),a("p",[e._v("使用cancel token 取消请求，可以使用CancelToken.source工厂方法创建cancel token")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var CancelToken = axios.cancelToken\nvar source = CancelToken.source()\n\naxios.get('/user/12321', {\n  cancelToken: source.token\n}).catch((thrown) => {\n  if (axios.isCancel(thrown)) {\n    console.log(thrown.message)\n  } else {\n    // 处理错误\n  }\n})\n\nsource.cancel('operation canceled by the user')\n")])]),a("p",[e._v("还可以通过传递一个executor 函数到CancelToken 的构造函数来创建 cancel token的身份验证")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var CancelToken = axios.CancelToken\nvar cancel\n\naxios.get('/user/12312', {\n  cancelToken: new CancelTokem(exector(c) => {\n    // exector函数接收一个cancel函数作为参数\n    cancel = c\n  })\n})\n")])])])}],!1,null,null,null);t.default=r.exports}}]);