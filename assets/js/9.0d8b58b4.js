(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{74:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"vuex"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex","aria-hidden":"true"}},[e._v("#")]),e._v(" vuex")]),n("h2",{attrs:{id:"vuex-getter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex-getter","aria-hidden":"true"}},[e._v("#")]),e._v(" vuex-getter")]),n("h3",{attrs:{id:"vuex中的getter使用属性访问和使用方法访问，但此处都是指的通过getter的返回值来访问，即返回值是属性或方法。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex中的getter使用属性访问和使用方法访问，但此处都是指的通过getter的返回值来访问，即返回值是属性或方法。","aria-hidden":"true"}},[e._v("#")]),e._v(" vuex中的getter使用属性访问和使用方法访问，但此处都是指的通过getter的返回值来访问，即返回值是属性或方法。")]),n("p",[e._v("getter接收state作为其第一个参数，调用时vuex会自动执行最外层函数,即state这一层。\n当通过属性访问时，getter是作为vue响应式系统的一部分缓存的，即只要是返回对象就会有缓存，除非state发生了变化")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("getters: {\n  //引自doneTodosCount返回的不是外层(state,getters)函数，而是return后边的返回值\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\ncomputed: {\n  doneTodosCount() {\n    return this.$store.getters.doneTodosCount\n  }\n}\n")])]),n("p",[e._v("而当通过方法访问时，getter每次都会重新进行调用，不会缓存结果")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("getters: {\n  // 此处getTodoById同理，返回的不是外层(state)函数，而是(id)内层函数，所以接收的时候也是(id)函数来接收参数\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n此处箭头函数普通形式为\ngetTodoById: function(state) {\n  return function(id) {\n    return state.todos.find(function(todo) {\n      return tood.id === id\n    })\n  }\n}\n调用时使用\nstore.getters.getTodoById(2)\n此处2直接传给(state) => (id)的内层函数(id)\n")])]),n("h2",{attrs:{id:"vuex简单示例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex简单示例","aria-hidden":"true"}},[e._v("#")]),e._v(" vuex简单示例")]),n("h3",{attrs:{id:"参照https-www-cnblogs-com-ghostwu-p-7521097-html"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参照https-www-cnblogs-com-ghostwu-p-7521097-html","aria-hidden":"true"}},[e._v("#")]),e._v(" (参照"),n("a",{attrs:{href:"https://www.cnblogs.com/ghostwu/p/7521097.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/ghostwu/p/7521097.html")]),e._v(")")]),n("h3",{attrs:{id:"一、使用vue-cli完成环境搭建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、使用vue-cli完成环境搭建","aria-hidden":"true"}},[e._v("#")]),e._v(" 一、使用vue-cli完成环境搭建")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1.npm install --global vue-cli 安装命令行工具\n2.vue init webpack vue-demo 生成一个webpack项目,名字为vue-demo\n3.cd vue-demo\n4.npm install\n5.npm run dev\n\n")])]),n("h3",{attrs:{id:"二、删除helloworld组件，将app-vue与router文件都变成原始状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、删除helloworld组件，将app-vue与router文件都变成原始状态","aria-hidden":"true"}},[e._v("#")]),e._v(" 二、删除helloworld组件，将App.vue与router文件都变成原始状态")]),n("p",[e._v("App.vue")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div id=\"app\"></div>\n</template>\n\n<script>\n  export default {\n    name: 'app'\n  }\n<\/script>\n")])]),n("p",[e._v("router-index.js")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\n//创建router实例，配置routes参数\nexport default new Router({\n  routes: [\n  {\n    path: '/'\n  }\n  ]\n})\n")])]),n("h3",{attrs:{id:"三、npm-i-vuex-save-dev"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、npm-i-vuex-save-dev","aria-hidden":"true"}},[e._v("#")]),e._v(" 三、npm i vuex --save-dev")]),n("h3",{attrs:{id:"四、-在main-js中引入vuex，并注册store，这样就可以使用this-store来获得这个容器了"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、-在main-js中引入vuex，并注册store，这样就可以使用this-store来获得这个容器了","aria-hidden":"true"}},[e._v("#")]),e._v(" 四、 在main.js中引入vuex，并注册store，这样就可以使用this.$store来获得这个容器了")]),n("p",[e._v("main.js")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue form 'vue'\nimport App form './App'\nimport router from './router'\n// 引入vuex\nimport Vuex from 'vuex'\n// 引入store\nimport store from './vuex/store'\n\n// 模块化打包系统中，使用vue.use来安装Vuex\nVue.use(Vuex)\n\n// 阻止vue在启动时生成生产提示\nvue.config.productionTip = false\n\n//创建vue实例，将组件、路由、与store挂载到实例上\nnew Vue({\n  el: '#app', // 替换页面中id为app的div元素\n  router, //挂载路由\n  store, // 注册store\n  template: '<App/>', // 告知页面这个组件用这样的标签来包裹着，并且使用它\n  components: { App } //告知当前页面想使用App这个组件\n})\n")])]),n("h3",{attrs:{id:"五、创建store-js，用于存放所有的状态（改变的数据）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五、创建store-js，用于存放所有的状态（改变的数据）","aria-hidden":"true"}},[e._v("#")]),e._v(" 五、创建store.js，用于存放所有的状态（改变的数据）")]),n("p",[e._v("store.js")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\n// 创建store，提供一个初始对象state，存放状态userName\nconst store = new Vuex.Store({\n  state: {\n    userName: 'ghostwu'\n  }\n})\n\nexport default store\n\n")])]),n("h3",{attrs:{id:"六、将状态中的数据渲染到组件中"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#六、将状态中的数据渲染到组件中","aria-hidden":"true"}},[e._v("#")]),e._v(" 六、将状态中的数据渲染到组件中")]),n("p",[e._v("在components下创建组件Main.vue")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n <div>{{myName}}</div>\n</template>\n\n<script>\n  export default {\n    name: 'Main',\n    // 通过计算属性获取存储在全局容器store中state保存的状态值\n    computed: {\n      myName() {\n        return this.$store.state.userName\n      }\n    }\n  }\n<\/script>\n")])]),n("h3",{attrs:{id:"七、在app-vue中引入组件main-vue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#七、在app-vue中引入组件main-vue","aria-hidden":"true"}},[e._v("#")]),e._v(" 七、在app.vue中引入组件Main.vue")]),n("p",[e._v("app.vue")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  // 此处div为绑定vue实例的div\n  <div id=\"app\">\n    <Mainc></Mainc>\n  </div>\n</template>\n\n<script>\nimport Mainc from './components/Main.vue'\n\nexport default {\n  name: 'app',\n  components: {\n    Mainc\n  }\n}\n<\/script>\n")])]),n("h3",{attrs:{id:"八、使用mutation改变状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#八、使用mutation改变状态","aria-hidden":"true"}},[e._v("#")]),e._v(" 八、使用mutation改变状态")]),n("p",[e._v("在vuex中，只有提交mutation才能改变状态，每个mutation都有一个字符串的事件类型（type)和一个回调函数,这个回调函数就是我们实际进行状态更改的地方，并且它会接收state作为第一个参数\n当触发事件类型（type)时，调用回调函数,使用store.commit方法")]),n("p",[e._v("store.js")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const store = new Vuex.Store({\n  state: {\n    userName: 'ghostwu'\n  },\n  mutations: {\n    // 此处showUserName为事件类型（type)，并且它会接收state作为第一个参数，msg即为store.commit处传入的载荷(payload),需要使用header.vue中的点击事件来传递\n    showUserName(state, msg) {\n      // 回调函数\n      state.userName = msg\n    }\n  }\n})\n")])]),n("p",[e._v("新建Header.vue")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    <input type="text" v-model="msg" />\n    <input type="button" @click="setName" value="点我" />\n  </div>\n</template>\n\n<script>\n  export default {\n    name: \'Header\',\n    data() {\n      return {\n        msg: \'\'\n      }\n    },\n    methods: {\n      setName() {\n        // 使用this.$store.commit 将载荷this.msg的值提交给showUserName\n        this.$store.commit(\'showUserName\', this.msg)\n      }\n    }\n  }\n<\/script>\n')])])])}],!1,null,null,null);t.default=a.exports}}]);