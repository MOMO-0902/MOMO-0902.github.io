(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{62:function(e,n,r){"use strict";r.r(n);var t=r(0),a=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"加密——rsa前端与后台的加密与解密"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#加密——rsa前端与后台的加密与解密","aria-hidden":"true"}},[e._v("#")]),e._v(" 加密——RSA前端与后台的加密与解密")]),r("h2",{attrs:{id:"什么是rsa加密"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是rsa加密","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是RSA加密")]),r("p",[e._v("RSA加密算法是一种非对称加密算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要肜另一个才能解密，利用对极大整数做因数分解的难度决定了RSA算法的可靠性")]),r("p",[e._v("RSA的算法涉及三个参数，n、e1、e2")]),r("p",[e._v("其中，n是两个大质数 p、q的积，n的二进制表示所占用的位数，就是所谓的密钥长度")]),r("p",[e._v("e1和e2是一对相关的值，e1可以任意取，但要求与(p-1) * (q-1)互质；再选择e2，要求(e2 * e1) = 1 (mod(p-1) * (q-1))")]),r("p",[e._v("(n,e1),(n,e2)就是密钥对，其中(n,e1)为公钥，(n,e2为公钥)")]),r("p",[e._v("RSA加密解密算法完全相同，设A为明文，B为密文，则：A = B ^ e2 (mod n) ;B = A ^ e1 (mod n)")]),r("p",[e._v("e2和e1可以互换使用，即:")]),r("p",[e._v("A = B ^ e1 (mod n); B = A ^ e2 (mod n)")]),r("p",[e._v("RSA算法原理可见：\n"),r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("阮一峰RSA加密算法一")]),r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("阮一峰RSA加密算法二")])]),r("h2",{attrs:{id:"rsa流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rsa流程","aria-hidden":"true"}},[e._v("#")]),e._v(" RSA流程")]),r("p",[e._v("1.后端生成publicKey与privateKey\n2.后端返回publicKey给前端\n3.前台使用publicKey给敏感字段加密\n4.使用post方式发送数据给后端\n5.后端使用publicKey与pvivateKey进行解密。")]),r("h3",{attrs:{id:"使用加密库cryptico为数据加密"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用加密库cryptico为数据加密","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用加密库cryptico为数据加密")]),r("p",[e._v("1.需要加密时先请求后台的getrsa接口，后台会返回加密公钥")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("api.js 管理接口地址\n// 获取 rsa\n'getrsa': '/api/safe/getrsa',\n\n")])]),r("p",[e._v("2.定义加密方法")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// services.js 配置请求方式与请求函数名称\nexport function getRsa() {\n  return http.get(apis.getrsa)\n}\n// 判断是生产环境才进行加密\nexport function encrypt(val) {\n  if (process.env.NODE_ENV === 'production') {\n    return getRsa().then( res => {\n      // 定义公钥为接口返回结果\n      const publicKey = res\n      // 实例化加密系数\n      const rsakey = new RSAKey()\n      // 根据 rsa加密公式 m^e = c (mod n)，使用公钥(n,e)对m进行加密，m即为加密指数'10001'\n      rsakey.setPublic(publicKey, '10001')\n      // 返回加密后的数据\n      return rsakey.encrypt(val)\n      })\n  } else {\n    // 如果不是生产环境，直接把promise状态变为已完成，返回成功状态（即不加密但会对执行加密成功后的函数）。\n    return Promise.resolve(val)\n  }\n}\n\n")])]),r("p",[e._v("3.为数据加密")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 引入加密函数\nimport { encrypt, postLoginInfo } from 'services'\n// 登录\nlogin() {\n  const params = {}\n  // 使用Promise.all()方法给数据加密，promise.all()访求提供了并行执行异步操作的能力，并且在所有异步操作执行完毕后才执行回调。all接收一个数组参数，里边的值最终都返回promise对象。然后放进一个数组中传给then,用values接收\n  Promise.all([\n    encrypt(this.password),\n    encrypt(this.phoneNum)\n    ]).then(values => {\n      params.pwd = vlaues[0]\n      params.mobile = values[1]\n      postLoginInfo(params).then((res) => {\n        this.$router.push('/')\n        }).catch((err) => {\n          console.log(err)\n        })\n    }).catch((err) => {\n      console.log(err)\n    })\n}\n")])])])}],!1,null,null,null);n.default=a.exports}}]);