(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{76:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"异步编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程","aria-hidden":"true"}},[e._v("#")]),e._v(" 异步编程")]),t("p",[e._v("异步编程的目标就是怎样让它更像同步编程,所谓异步，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\n这种不连续执行的任务，就叫做异步。而连续的任务，就叫做同步。")]),t("h1",{attrs:{id:"回调函数-callback-重新调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数-callback-重新调用","aria-hidden":"true"}},[e._v("#")]),e._v(" 回调函数--callback(重新调用)")]),t("p",[e._v("js语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。")]),t("p",[e._v("ex:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 此例中，第一个参数，'/etc/passwd'即为任务要执行的第一段，请求文件，当请求文件成功后，执行函数的第二个参数，即为任务的第二段。\nfs.readFile('/etc/passwd',function(err,data) {\n  if (err) throw error\n  alert(data)\n  })\n")])]),t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),t("p",[e._v("如果多个回调函数嵌套，代码不是纵向谝，而是横向发展(执行最外层回调函数的同时执行第二个回调函数。。。)，很快就会乱成一团，无法管理。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fs.readFile(fileA, function(err, data) {\n  rs.readFile(fileB,function(err, data) {\n    ...\n    })\n  })\n")])]),t("p",[e._v("promise对象可以理解为一次执行的异步操作，只\npromise为解决多个回调函数嵌套问题产生。允许将回调函数的横向加载，改成纵向加载，连续读取多个文件，按步骤执行，执行完上一下再执行下一个，写法如下：\nex1:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let myPromise = new Promise(function(resolve, reject) {\n  // 250秒后将promise状态变为成功\n  setTimeout(function() {\n    resolve('成功')\n  }),250\n})\n// 使用then方法返上述定义的mypromise对象,因为then方法返回一个新的promise对象，这个对象取决于onFulFilled状态（即then方法)的返回值，而在链式调用中，除第一个外每一个onFulFilled的入参都是上一个onFulFilled的返回值，如果不在then方法中返回值，那么再次调用时就是undefined.\nmyPromise.then(function(message) {\n  alert('yee!' + message)\n  return myPromise\n}).then(function(message) {\n  alert('yee!' + message + 'again')\n  return myPromise\n})\n\n")])]),t("p",[e._v("ex2:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var readFile = require('fs-readfile-promise')\nreadFile(fielA)\n// 当fileA文件读取成功后转成字符串打印\n.then(function(data) {\n  alert(data.toString())\n})\n// 执行完readFileA回调函数后再执行readFileB\n.then(function() {\n  return readFile(fileB)\n})\n// fileB读取成功后转成字符串打印\n.then(function() {\n  alert(data.toString())\n})\n")])]),t("h1",{attrs:{id:"协程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协程","aria-hidden":"true"}},[e._v("#")]),e._v(" 协程")]),t("p",[e._v("协和意思是多个线程互相协作，完成异步任务。\n第一步，协程A开始执行。\n第二步，协程A执行到一半，进入暂停，执行权转移到协程By。\n第三步，（一段时间后）协和B交还执行权。\n第四步，协程A恢复执行。")]),t("p",[e._v("协和遇到 yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行，它最大优点是写法非常像同步操作。、")]),t("h1",{attrs:{id:"generator函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator函数","aria-hidden":"true"}},[e._v("#")]),e._v(" Generator函数")]),t("h4",{attrs:{id:"generator函数的数据交换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator函数的数据交换","aria-hidden":"true"}},[e._v("#")]),e._v(" generator函数的数据交换")]),t("p",[e._v("generator函数是协程es6的实现 ，最大特点就是可以交出函数的执行权（即暂停执行）")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* gen(x) {\n  var y = yield x + 2\n  return y\n}\n")])]),t("p",[e._v("整个generator函数就是一个封装的异步任务，异步操作需要暂停的地方，都用yield声明，generator函数的执行方法如下：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 调用generator函数，返回一个内部指针（即遍历器）g，将1传到gen函数中\nvar g = gen(1)\ng.next() // {value: 3, done: flase}\ng.next()//{value: undefined, done: true}\n")])]),t("p",[e._v("generator函数不会返回结果，而是返回指针对象，表示当前阶段作息（value是yield语句后边表达式的值，表示当前阶段的值，done表示generator函数是否执行完毕）。调用 g 的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x+2为止，当再次调用的时候程序从“var y = yield x + 2”处开始执行，后边没有语句了，直接return y肯定是undefined。")]),t("p",[e._v("next方法返回值的value属性，是generator函数向外输入数据；next方法还可以接收参数，传入遍历器g中，作为上个阶段异步任务的返回结果。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function* () {\n  var y = yield x + 2\n  return y\n}\nvar g = gen(1)\ng.next() // {value: 3, done: false}\ng.next(2) // {value: 2, done: true}\n// 此处g.next(2)将2赋值给"var y = yield x + 2"处的y，即上面提到的作为上个阶段异步任务的返回结果。\n')])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* () {\n  var y = yield x + 2\n  return y\n}\nvar g = gen(1)\ng.next(2) // {value: 3, done: false}\ng.next() // {value: undefined, done: true}\n// 第一次调用 g.next(2)中传入的参数2是无效，因为在遍历器生成的时候就用var g = gen(1)传入了参数，调用g的next方法会产出生成时传入的参数，所以结果还是1,第二次调用 g.next()并没有传入参数，所以用return y 返回结果是undefined\n")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* () {\n  var y = yield x + 2\n  return y\n}\nvar g = gen(1)\ng.next(2) // {value: 3, done: false}\ng.next(5) // {value: 5, done: true}\n// 此处 赋值5给y后直接返回y所以结果是5\n")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* () {\n  var y = yield x + 2\n  console.log(y)\n  y = x\n}\nvar g = gen(1)\ng.next() // {value: 3, done: false}\ng.next(5) // {value: 1, done: true}\n结果： 5\n      {value: 1, done: true}\n// 此处赋值给y后重新赋值y给x，所以结果是1\n")])]),t("h2",{attrs:{id:"generator函数的错误处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator函数的错误处理","aria-hidden":"true"}},[e._v("#")]),e._v(" generator函数的错误处理")]),t("p",[e._v("function* gen(x) {\ntry {\nvar y = yield x + 2\n} catch(e) {\nconsole.log(e)\n}\nreturn y\n}\nvar g = gen(1)\ng.next()\ng.throw('出错了')")]),t("h2",{attrs:{id:"generator函数的用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator函数的用法","aria-hidden":"true"}},[e._v("#")]),e._v(" generator函数的用法")]),t("p",[e._v("var fetch = require('node-fetch')")]),t("p",[e._v("function* gen() {\nvar url = 'https://api.github.com/users/github'\nvar result = yield fetch(url)\nconsole.log(result.bio)\n}\nvar g =gen()\nvar result = g.next()\nresult.value.then(function(data) {\nreturn data.json()\n}).then(function(data) {\ng.next(data)\n})")]),t("h1",{attrs:{id:"async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async","aria-hidden":"true"}},[e._v("#")]),e._v(" async")]),t("h2",{attrs:{id:"async是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async是什么","aria-hidden":"true"}},[e._v("#")]),e._v(" async是什么")]),t("p",[e._v("async是generator函数的语法糖。只是将generator里的*替换成了async表示里边有异步函数，yield替换成了await表示紧跟在后边的表达式需要等待结果。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function timeout(ms) {\n  return new Promise((resolve) {\n    setTimeout(resolve, ms)\n    })\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms)\n  console.log(value)\n}\n\nasyncPrint('hello', 50)\n// 指定50秒后输出hello\n")])])])}],!1,null,null,null);n.default=r.exports}}]);