<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>霍梦林的个人博客 | 定义</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/46.styles.b646c9c7.css" as="style"><link rel="preload" href="/assets/js/app.21af4b7a.js" as="script"><link rel="preload" href="/assets/js/28.00a64dc0.js" as="script"><link rel="prefetch" href="/assets/js/23.62bfb48a.js"><link rel="prefetch" href="/assets/js/0.ad434982.js"><link rel="prefetch" href="/assets/js/1.de00d4e2.js"><link rel="prefetch" href="/assets/js/2.8e4568be.js"><link rel="prefetch" href="/assets/js/3.ba3de1c7.js"><link rel="prefetch" href="/assets/js/4.ed75d86a.js"><link rel="prefetch" href="/assets/js/5.f5b66771.js"><link rel="prefetch" href="/assets/js/6.ac2b7510.js"><link rel="prefetch" href="/assets/js/7.849df679.js"><link rel="prefetch" href="/assets/js/8.32604b3f.js"><link rel="prefetch" href="/assets/js/9.65cc79e2.js"><link rel="prefetch" href="/assets/js/10.bee2823d.js"><link rel="prefetch" href="/assets/js/11.dbec1204.js"><link rel="prefetch" href="/assets/js/12.4cc4f4b0.js"><link rel="prefetch" href="/assets/js/13.fb4a1834.js"><link rel="prefetch" href="/assets/js/14.d2671700.js"><link rel="prefetch" href="/assets/js/15.31de3449.js"><link rel="prefetch" href="/assets/js/16.357740a9.js"><link rel="prefetch" href="/assets/js/17.285d1748.js"><link rel="prefetch" href="/assets/js/18.924155d6.js"><link rel="prefetch" href="/assets/js/19.d96ed59a.js"><link rel="prefetch" href="/assets/js/20.67ee3641.js"><link rel="prefetch" href="/assets/js/21.3443a30e.js"><link rel="prefetch" href="/assets/js/22.15d6b2e5.js"><link rel="prefetch" href="/assets/js/24.bbcffed2.js"><link rel="prefetch" href="/assets/js/25.2d46b06d.js"><link rel="prefetch" href="/assets/js/26.18ff9f32.js"><link rel="prefetch" href="/assets/js/27.eb667acf.js"><link rel="prefetch" href="/assets/js/29.0dd9e08c.js"><link rel="prefetch" href="/assets/js/30.356525db.js"><link rel="prefetch" href="/assets/js/31.b9ad12f5.js"><link rel="prefetch" href="/assets/js/32.bc18723d.js"><link rel="prefetch" href="/assets/js/33.395c2652.js"><link rel="prefetch" href="/assets/js/34.dc6f2133.js"><link rel="prefetch" href="/assets/js/35.cff13afc.js"><link rel="prefetch" href="/assets/js/36.e1ccc63a.js"><link rel="prefetch" href="/assets/js/37.87a3a50b.js"><link rel="prefetch" href="/assets/js/38.20975580.js"><link rel="prefetch" href="/assets/js/39.fe1ec382.js"><link rel="prefetch" href="/assets/js/40.0fa937cf.js"><link rel="prefetch" href="/assets/js/41.1dfcb875.js"><link rel="prefetch" href="/assets/js/42.f3ddae5b.js"><link rel="prefetch" href="/assets/js/43.c234813d.js"><link rel="prefetch" href="/assets/js/44.ee33685d.js"><link rel="prefetch" href="/assets/js/45.d7f97673.js">
    <link rel="stylesheet" href="/assets/css/46.styles.b646c9c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      霍梦林的个人博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/problem/" class="nav-link">Problem</a></div><div class="nav-item"><a href="/study/" class="nav-link router-link-active">Study</a></div><div class="nav-item"><a href="http://blog.csdn.net/weixin_38318244/" target="_blank" rel="noopener noreferrer" class="nav-link">CSDN</a></div><div class="nav-item"><a href="https://github.com/momo-0902" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/problem/" class="nav-link">Problem</a></div><div class="nav-item"><a href="/study/" class="nav-link router-link-active">Study</a></div><div class="nav-item"><a href="http://blog.csdn.net/weixin_38318244/" target="_blank" rel="noopener noreferrer" class="nav-link">CSDN</a></div><div class="nav-item"><a href="https://github.com/momo-0902" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div><!----></nav><ul class="sidebar-links"><li><a href="/study/" class="sidebar-link">学习笔记</a></li><li><a href="/study/axios.html" class="active sidebar-link">1.axios</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/axios.html#定义" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#特征" class="sidebar-link">特征</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#使用" class="sidebar-link">使用</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#配置" class="sidebar-link">配置</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#请求方式别名" class="sidebar-link">请求方式别名</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#创建实例" class="sidebar-link">创建实例</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#实例方法" class="sidebar-link">实例方法</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#请求配置" class="sidebar-link">请求配置</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#响应信息" class="sidebar-link">响应信息</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#配置默认值" class="sidebar-link">配置默认值</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#自定义实例默认值" class="sidebar-link">自定义实例默认值</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#配置的优先顺序" class="sidebar-link">配置的优先顺序</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#拦截器" class="sidebar-link">拦截器</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#移除拦截器" class="sidebar-link">移除拦截器</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#为自定义实例添加拦截器" class="sidebar-link">为自定义实例添加拦截器</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#错误处理" class="sidebar-link">错误处理</a></li><li class="sidebar-sub-header"><a href="/study/axios.html#取消请求" class="sidebar-link">取消请求</a></li></ul></li><li><a href="/study/document.html" class="sidebar-link">2.document</a></li><li><a href="/study/css.html" class="sidebar-link">3.css</a></li><li><a href="/study/css-selector.html" class="sidebar-link">4.css选择器</a></li><li><a href="/study/flex.html" class="sidebar-link">5.flex</a></li><li><a href="/study/git.html" class="sidebar-link">6.git</a></li><li><a href="/study/html.html" class="sidebar-link">7.html</a></li><li><a href="/study/http.html" class="sidebar-link">8.http</a></li><li><a href="/study/input.html" class="sidebar-link">9.input</a></li><li><a href="/study/js-basis.html" class="sidebar-link">10.js语言基础</a></li><li><a href="/study/RSA-encrypt.html" class="sidebar-link">12.RSA加密</a></li><li><a href="/study/vue-router.html" class="sidebar-link">13.vue-router</a></li><li><a href="/study/vue.html" class="sidebar-link">14.vue</a></li><li><a href="/study/vuex.html" class="sidebar-link">15.vuex</a></li><li><a href="/study/vuePress.html" class="sidebar-link">16.vuePress</a></li><li><a href="/study/zepto.html" class="sidebar-link">17.zepto</a></li><li><a href="/study/code-optimization.html" class="sidebar-link">18.代码逻辑优化</a></li><li><a href="/study/scroll-page-bottom.html" class="sidebar-link">19.判断是否滚动到页面底部</a></li><li><a href="/study/find-the-cause-of-error.html" class="sidebar-link">20.找错误原因</a></li><li><a href="/study/local-cache.html" class="sidebar-link">21.本地缓存</a></li><li><a href="/study/algorithm.html" class="sidebar-link">22.算法</a></li><li><a href="/study/vue-accordion.html" class="sidebar-link">23.vue使用事件委托实现手风琴</a></li><li><a href="/study/generator.html" class="sidebar-link">24.异步编程-generator</a></li><li><a href="/study/capture-debugging-tool.html" class="sidebar-link">25.抓包调试工具</a></li><li><a href="/study/art-template.html" class="sidebar-link">26.art-template</a></li><li><a href="/study/bootstrap-datepicker.html" class="sidebar-link">27.bootstrap-datepicker</a></li><li><a href="/study/simulation-form-submit.html" class="sidebar-link">28.模拟form提交表单</a></li><li><a href="/study/echarts.html" class="sidebar-link">29.echarts封装渲染和部分配置</a></li><li><a href="/study/return-specific-date.html" class="sidebar-link">30.返回某个月的某个星期几</a></li><li><a href="/study/prevent-duplicate-request.html" class="sidebar-link">31.防止接口重复请求</a></li><li><a href="/study/table.html" class="sidebar-link">32.table的操作</a></li><li><a href="/study/not-yet-classified.html" class="sidebar-link">33.暂未分类</a></li></ul></div><div class="page"><div class="content"><h2 id="定义"><a href="#定义" aria-hidden="true" class="header-anchor">#</a> 定义</h2><p>axios是一个基于Promise用于浏览器和nodejs的http客户端</p><h2 id="特征"><a href="#特征" aria-hidden="true" class="header-anchor">#</a> 特征</h2><ul><li>从浏览器中创建XMLHttpRequest</li><li>从nodejs发出http请求</li><li>支持Promise api</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换json数据</li><li>客户端支持防止 CSRF/XSRF(跨站请求伪造，也被称为one click attack/session riding，CRSF攻击可理解为攻击者盗用了你的身份，以你的名义发送恶意请求，会导致个人隐私泄露及财产安全问题。)</li></ul><h2 id="使用"><a href="#使用" aria-hidden="true" class="header-anchor">#</a> 使用</h2><h3 id="执行get请求"><a href="#执行get请求" aria-hidden="true" class="header-anchor">#</a> 执行get请求</h3><p>1.可通过params对象传递参数</p><pre class="language-text"><code>axios.get(url, {
  params: {}
})
     .then(() =&gt; {})
     .catch(() =&gt; {})
</code></pre><p>2.也可直接将参数拼接在路径后边</p><pre class="language-text"><code>axios.get('/user?id=12321')
</code></pre><h3 id="执行post请求"><a href="#执行post请求" aria-hidden="true" class="header-anchor">#</a> 执行post请求</h3><pre class="language-text"><code>axios.post(url, data)
</code></pre><h3 id="执行多个并发请求"><a href="#执行多个并发请求" aria-hidden="true" class="header-anchor">#</a> 执行多个并发请求</h3><pre class="language-text"><code>getUserAccount() {
  axios.get('/user/12345')
}

getUserPermissions() {
  axios.get('/user/permissions')
}

axios.all([getUserAccount(), getUserPermissions()])
     .then(axios.sperad(function(acct,perms) {
       // 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果
      }))
     .catch(() =&gt; {})
</code></pre><h2 id="配置"><a href="#配置" aria-hidden="true" class="header-anchor">#</a> 配置</h2><p>可以对axios进行一些设置来生成请求
1.</p><pre class="language-text"><code>axios(config)
axios({
  methods,
  url,
  data,
})

ex: 发送一个post请求
axios({
  methods: 'POST',
  url: '/user/12321',
  data: {
    firstName: 'fred',
    lastName: 'mary'
  }
})
</code></pre><p>2.axios(url[,config])
发送一个get请求，get是默认请求方式</p><pre class="language-text"><code>axios('/user/12321')
</code></pre><h2 id="请求方式别名"><a href="#请求方式别名" aria-hidden="true" class="header-anchor">#</a> 请求方式别名</h2><pre class="language-text"><code>axios.request(config)
axios.get(url[,config])
axios.delete(url[,config])
axios.head(url[,config])
axios.post(url[,data[,config]])
axios.put(url,[,data[,config]])
axios.patch(url,[,data[,config]])
</code></pre><h2 id="创建实例"><a href="#创建实例" aria-hidden="true" class="header-anchor">#</a> 创建实例</h2><pre class="language-text"><code>axios.create([config])

var instance = axios.create({
  baseURl: '',
  timeout: 1000,
  headers: {}
})
</code></pre><h2 id="实例方法"><a href="#实例方法" aria-hidden="true" class="header-anchor">#</a> 实例方法</h2><pre class="language-text"><code>axios#request(config)
axios#get(url[,config])
axios#delete(url[,config])
axios#head(url[,config])
axios#post(url[,data[,config]])
axios#put(url,[,data[,config]])
axios#patch(url,[,data[,config]])
</code></pre><h2 id="请求配置"><a href="#请求配置" aria-hidden="true" class="header-anchor">#</a> 请求配置</h2><pre class="language-text"><code>{
  url,
  methods,
  baseURL,
  // 对请求数据的改动
  transformRequest: [function(data) {
    return data
  }],
  // 在数据传送到'then/catch'之前对数据进行改动
  transformResponse: [function(data) {
    return data
  }],
  headers,
  params,
  paramsSerializer: function(params) {
    return Qs.stringify(params, {arrayFormatL: 'brackets'})
  },
  data: {}
  timeout,
  // 表示跨域请求时是否需要凭证
  withCredentials: false,
  // 允许自定义请求
  adaptefr: function(config) {},
  // 'auth'表示应该使用http基础验证，并提供凭据,这将设置一个'Authorization'头，覆写掉现有的任意使用'headers'设置的自定义'Authorization'头
  auth: {
    username: '',
    password: ''
  },
  responseType: '',
  // 承载 xsrf token 的值的http头名称
  xsrfHeaderName: 'X-XSRF-TOKEN',
  // 允许为上传处理进度事件
  onUploadProgress: function(progressEvent) {
    //对原生事件的处理
  },
  // 定义允许的响应内容的最大尺寸
  maxContentLength,
  根据此函数返回的值定义promise的状态为resolve或rejected
  validateStatus: function(status) {
    return status &gt;= 200 &amp;&amp; status &lt; 300
  },
  // 定义在nodejs中follow是最大重定向数目
  maxRedirects: 5,
  // 在nodejs中定义在执行http和https时使用的自定义代理
  httpAgent: new http.Agent({ keepAlive: true}),
  httpsAgent: new https.Agent({ keepAlive: true}),
  // proxy定义代理服务器的主机名称和端口，auth表示http基础验证应当用于连接代理，并提供凭据
  proxy: {
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: '',
      password: ''
    }
  },
  // 指定用于取消请求的cancel token
  cancelToken: new cancelToken(function(cancel) {})
}
</code></pre><h2 id="响应信息"><a href="#响应信息" aria-hidden="true" class="header-anchor">#</a> 响应信息</h2><pre class="language-text"><code>{
  data: {}, //数据
  status: 200, //状态码
  statusText: 'OK', // 服务器响应的http状态信息
  headers: {}, 服务器响应头
  config: {} //为请求提供的配置信息
}
</code></pre><p>使用then时可用response参数来接收响应
axios.get('/user/12321')
.then(function(response) {
console.log(response.data)
console.log(response.status)
……
})</p><h2 id="配置默认值"><a href="#配置默认值" aria-hidden="true" class="header-anchor">#</a> 配置默认值</h2><ul><li>全局的axios默认值</li></ul><pre class="language-text"><code>axios.defaults.baseURL = ''
// 设置请求头信息为AUTH_TOKEN
axios.defaluts.headers.common['Authorization'] = AUTH_TOKEN
// 设置请求的媒体类型
axios.defaults.headers.post['Content-Type'] = 'application/x-www-fomr-urlencoded'
// 允许跨域的情况下携带cookie
axios.defaults.withCredentials = true
// 标识这是一个ajax请求
axios.defaults.headers.common['X-Request-With'] = 'XMLHttpRequest'
</code></pre><h2 id="自定义实例默认值"><a href="#自定义实例默认值" aria-hidden="true" class="header-anchor">#</a> 自定义实例默认值</h2><pre class="language-text"><code>var instance = axios.create({
  baseURL: 'https://api.example.com'
})

// 在实例忆创建后修改默认值
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN
</code></pre><h2 id="配置的优先顺序"><a href="#配置的优先顺序" aria-hidden="true" class="header-anchor">#</a> 配置的优先顺序</h2><p>在lib/defaults.js中找到库的默认值，然后是实例的defaults属性，最后是config请求参数</p><pre class="language-text"><code>var instance = axios.create()

instance.defaults.timeout = 2000

instance.get('/longRequest', {
  timeout: 5000
})
</code></pre><h2 id="拦截器"><a href="#拦截器" aria-hidden="true" class="header-anchor">#</a> 拦截器</h2><p>在请求或响应被then或catch之前拦截它们，此例包括封装axios--http.js</p><pre class="language-text"><code>// 在请求发出之前拦截
axios.interceptors.request.use(config =&gt; {
  return config
}, error =&gt; {
  return Promise.rejected(error)
})

*ex:
// 此处在请求发出之前，将config参数中的请求头授权为AUTH_TOKEN
axios.interceptors.request.use(config =&gt; {
  let AUTH_TOKEN = storage.get('AUTH_TOKEN')
  if (AUTH_TOKEN) {
    config.headers['Authorization']
  }
})


// 在响应之前拦截
axios.interceptors.response.use(response =&gt; {
  return response
}, error =&gt; {
  return Promise.rejected(error)
})


* ex:
axios.interceptors.response.use(response =&gt; {
  if (response.data.retcode === 2000000) {
    return response.data.data || response.data.data
  } esle {
    throw Error(response.data.msg || '服务异常')
  }
}, err =&gt; {
  if(err &amp;&amp; err.message) {
    let retcode = err.response.data.retcode
    // 401为后台返回的状态未登录
    if (err.response.status === '401') {
      // 移除token信息
      storage.remove('AUTH_TOKEN')
    }
    if (err.response.status === 500) {
      err.message = err.response.data.message || '系统异常'
      err.retcode = retcode
    }
  }
  return Promise.reject(err)
})

export default axios
</code></pre><p>封装接口地址api.js</p><pre class="language-text"><code>const prefix = window._CONFIG_.apiPath
export default (config =&gt; {
  return Object.keys(config).reduce((copy,name) =&gt; {
    copy[name] = `${prefix}${config[name]}`
    return copy
}, {})
})({
  // 接口地址
  user: '/api/user/user'
  ……
})
</code></pre><p>定义相关请求server.js</p><pre class="language-text"><code>import api from '../api'
impost axios from '../http'
export function getUserInfo(userId) {
  return axios.get(api.user, params)
}
</code></pre><p>调用相关接口 getUser.js</p><pre class="language-text"><code>import {getUserInfo} from '../server'
getUserInfo({userId: userId})
  .then((resp) =&gt; {
   console.log(resp)
   if (res.retcode === 2000000) {}
   if (res.retcode === 300000) {}
}).catch((err) =&gt; {
    console.log(err.message)
  })
</code></pre><h2 id="移除拦截器"><a href="#移除拦截器" aria-hidden="true" class="header-anchor">#</a> 移除拦截器</h2><pre class="language-text"><code>var myInterceptor = axios.interceptors.request.use(config =&gt; {})
axios.interceptor.request.eject(myInterceptor)
</code></pre><h2 id="为自定义实例添加拦截器"><a href="#为自定义实例添加拦截器" aria-hidden="true" class="header-anchor">#</a> 为自定义实例添加拦截器</h2><pre class="language-text"><code>var instance = axios.create()
instance.interceptors.request.use(config =&gt; {})

</code></pre><h2 id="错误处理"><a href="#错误处理" aria-hidden="true" class="header-anchor">#</a> 错误处理</h2><p>可以使用validateStatus 配置选项定义一个自定义http状态码的错误范围</p><pre class="language-text"><code>axios.get('/user/123213', {
  validateStatus: (status) =&gt; {
    return status&lt; 500 //状态码在大于或等于500时才会reject
  }
})

</code></pre><h2 id="取消请求"><a href="#取消请求" aria-hidden="true" class="header-anchor">#</a> 取消请求</h2><p>使用cancel token 取消请求，可以使用CancelToken.source工厂方法创建cancel token</p><pre class="language-text"><code>var CancelToken = axios.cancelToken
var source = CancelToken.source()

axios.get('/user/12321', {
  cancelToken: source.token
}).catch((thrown) =&gt; {
  if (axios.isCancel(thrown)) {
    console.log(thrown.message)
  } else {
    // 处理错误
  }
})

source.cancel('operation canceled by the user')
</code></pre><p>还可以通过传递一个executor 函数到CancelToken 的构造函数来创建 cancel token的身份验证</p><pre class="language-text"><code>var CancelToken = axios.CancelToken
var cancel

axios.get('/user/12312', {
  cancelToken: new CancelTokem(exector(c) =&gt; {
    // exector函数接收一个cancel函数作为参数
    cancel = c
  })
})
</code></pre></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/study/" class="prev router-link-active">
          学习笔记
        </a></span><span class="next"><a href="/study/document.html">
          2.document
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/28.00a64dc0.js" defer></script><script src="/assets/js/app.21af4b7a.js" defer></script>
  </body>
</html>
